#! /usr/bin/env tclsh

# $Id: analyse_config,v 1.4.4.8 2010-10-26 11:22:48 imiell Exp $
global INDENTS
set INDENTS 0

####################
proc printUsage {} {
####################
#-------------------------------
# General usage
#-------------------------------
	log {Usage: analyse_config [-cfg <config item1,config item n>] [-location] [-history] [-overwrites] [-d <dir>] [-compare <config file2>] [-log] [-view] [-tail] [-quiet] [-h|--help] [--version] <config file>}
	log {    -cfg <config item1,config item n> - limit output to specific config items (consider grep)}
	log {    -location                         - output the config file that the item was last set in}
	log {    -history                          - gives values' value history in the order of cfg sourcing}
	log {    -overwrites                       - adds a column at the end that indicates the number of times a cfg item was overwritten}
	log {    -d <dir>                          - run as if from a specific directory, if you just put -d it will run}
	log {                                        as if from the current dir, if you don't put a -d it will run from}
	log {                                        the directory of the config file}
	log {    -compare <config file2>           - compare two config files}
	log {    -log                              - print out the current log file}
	log {    -view                             - less the current log file}
	log {    -tail                             - tails the current log file}
	log {    -quiet                            - only scan files for errors and includes, don't print settings}
	log {    -h/--help                         - show this help}
	log {    --version                         - show version string}
	log { }
	log {Example:}
	log {     analyse_config -history -cfg PORTS,CGI_URL ~/lbr_sports/comapp21-sports.cfg}
	exit
}


#################
proc log {text} {
#################
	global INDENTS
	for {set i 0} {$i < $INDENTS} {incr i} {
		puts -nonewline stderr "    "
	}
	puts stderr $text
}


#################
proc array_compare {array1 array2} {
#################
	upvar #0 $array1 ARRAY1
	upvar #0 $array2 ARRAY2

	set nosetin1 [list]
	foreach name [lsort [array names ARRAY1 {*,name} ]] {
		regsub {^(.*),name$} $name {\1} conf_name

		if {[info exists ARRAY2($conf_name,value)]} {
			if {$ARRAY2($conf_name,value) != $ARRAY1($conf_name,value)} {
				puts "$conf_name"
				puts [format {   PRIMARY: %-40s --> %-30s} $ARRAY1($conf_name,value) $ARRAY1($conf_name,location)]
				puts [format {   COMPARE: %-40s --> %-30s} $ARRAY2($conf_name,value) $ARRAY2($conf_name,location)]
			}
		} else {
			puts "$conf_name"
			puts [format { PRIMARY: %-40s --> %-30s} $ARRAY1($conf_name,value) $ARRAY1($conf_name,location)]
			puts [format { COMPARE: %-40s --> %-30s} "NOT SET" "NA"]
		}
	}
	puts ""
}


########################
proc parseFile {fname {conf CONFIG}} {
########################
# -------------------------------------------------------------
# Gets config entries from file and puts them in global CONFIG.
# Makes a recursive call on encountering an include.
# -------------------------------------------------------------

	upvar #0 $conf cfg
	global INDENTS
	global env

	 set SETTINGS(substenv)  0
	 set SETTINGS(substconf) 0

	if [catch {set fileid [open $fname "r"]} msg] {
		log "ERROR : Cannot open file for reading: $fname"
		return
	}

	log "parsing file $fname"

	fconfigure $fileid -buffering line

	set prev_line ""

	while {![eof $fileid]} {
		gets $fileid line

		# cope with trailing backslashes by joining such lines with space.
		if {[regexp {\\$} $line]} {
			append prev_line "[string range $line 0 end-1] "
			continue
		} else {
			if {[string length $prev_line]} {
				set line "$prev_line $line"
			}
			set prev_line ""
		}

		# ignore comment lines beginning with # or empty lines
		if {[string index $line 0] == "#" || [regexp -- {^\s*$} $line]} {
			continue
		}

		# Support substenv
		if {[info exists SETTINGS(substenv)] && $SETTINGS(substenv) == 1} {
			catch {
				regsub -all {\$\((\S+)\)} $line {$env(\1)} unsubstval
				set line [subst -nobackslashes -nocommands $unsubstval]
			}
		}

		# Support substconf
		if {[info exists SETTINGS(substconf)] && $SETTINGS(substconf) == 1} {
			catch {
				regsub -all {\$\((\S+)\)} $line {$cfg(\1,value)} unsubstval
				set line [subst -nobackslashes -nocommands $unsubstval]
			}
		}

		# Match [spaces]arg[spaces]=[spaces]val[spaces] (val may contain spaces)
		if {[regexp {^\s*(\S*)\s*\=\s*(.*)\s*$} $line all arg val]} {
			set arg [string trim $arg]
			set val [string trim $val]
			registerConfig $arg $val $fname $conf
			continue
		}

		# Match substenv
		if {[regexp {^!pragma\s+substenv\s*$} $line all]} {
			set SETTINGS(substenv) 1
			continue
		}

		# Match substcfg
		if {[regexp {^!pragma\s+substcfg\s*$} $line all]} {
			set SETTINGS(substconf) 1
			continue
		}

		# Match !include[spaces]val[spaces]
		if {[regexp {^!include\s+(\S+)\s*$} $line all subfile]} {
			incr INDENTS
			parseFile $subfile $conf
			incr INDENTS -1
		} else {
			log "ERROR : Rogue line in config file: \[$line\]"
		}
	}

	close $fileid
}


########################################
proc registerConfig {arg val location {conf CONFIG}} {
########################################
#------------------------------------------------------------------
# Build the configs array and keep track of where the config is set
#------------------------------------------------------------------
	upvar #0 $conf cfg
	global SETTINGS
	global env
	# Establish config details, get as much detail as possible
	if {[info exists cfg($arg,value)]} {
		incr cfg($arg,overwrites)
		set cfg($arg,location) $location
		set cfg($arg,$cfg($arg,overwrites),location) $location
		set cfg($arg,$cfg($arg,overwrites),value)    $val
		set cfg($arg,value)    $val
	} else {
		set cfg($arg,value)      $val
		set cfg($arg,name)       $arg
		set cfg($arg,location)   $location
		set cfg($arg,0,location) $location
		set cfg($arg,0,value)    $val
		set cfg($arg,overwrites) 0
	}
}


#######################
proc outputConfigs {{conf CONFIG} {config_list "null"}} {
#######################
#-------------------------------------------
# Format and output the configuration setup
#-------------------------------------------

	upvar #0 $conf cfg
	global SETTINGS

	if {$SETTINGS(configs) == "all" && $config_list == "null"} {
		set SETTINGS(configs) [list]
		set configs_tmp [array names cfg {*,name}] ;# TODO
		foreach conf_tmp $configs_tmp {
			regsub {^(.*),name$} $conf_tmp {\1} dummy1
			lappend SETTINGS(configs) $dummy1
		}
	}

	if {$config_list != "null"} {
		set $SETTINGS(configs) $config_list
	}

	foreach name [lsort $SETTINGS(configs)] {
		if {[info exists cfg($name,value)]} {
			puts -nonewline "[format {%-40s = %-30s} $name  $cfg($name,value)]"
			if {$SETTINGS(overwrites)} { puts -nonewline "\t$cfg($name,overwrites)" }
			if {$SETTINGS(location)}   { puts -nonewline "\t$cfg($name,location)" }

			if {$SETTINGS(history)} {
				puts ""
				for {set i 0} {$i <= $cfg($name,overwrites)} {incr i } {
					if {$i != 0 && $cfg($name,$i,value) == $cfg($name,[expr {$i - 1}],value)} {
						puts "$cfg($name,$i,value) == $cfg($name,[expr {$i - 1}],value)"
						puts "[format {    HISTORY %-40s %-40s %-30s} $name REPEATED $cfg($name,$i,location)]"
					} else {
						puts "[format {    HISTORY %-40s %-40s %-30s} $name $cfg($name,$i,value) $cfg($name,$i,location)]"
					}
				}
			}
			puts ""
		}
	}
}

# set up SETTINGS global.
set SETTINGS(history)    0
set SETTINGS(overwrites) 0
set SETTINGS(location)   0
set SETTINGS(configs)    all
set SETTINGS(quiet)      0
set SETTINGS(get_log)    0
set SETTINGS(taillog)    0
set SETTINGS(viewlog)    0
set SETTINGS(directory)  unset
set SETTINGS(compare)    0

if {[llength $argv] >= 1} {
	for {set i 0} {$i < [llength $argv]} {incr i} {
		catch {unset param}
		catch {unset val}
		set arg [lindex $argv $i]
		# We still support = as a value-setter for backwards-compatibility.
		if {[string match "*=*" $arg]} {
			regexp {([^=]*)=([^=]*)} $arg dummy param val
			if {![info exists param]} {
				set param $arg
				set val   $arg
			}
		} else {
			set param $arg
		}
		switch -- $param {
			{-history}     {set SETTINGS(history)    1}
			{-compare}     {if {![info exists val]} {incr i; set val [lindex $argv $i]}; set SETTINGS(compare) $val}
			{-cfg}         {if {![info exists val]} {incr i; set val [lindex $argv $i]}; set SETTINGS(configs) [split $val ","]}
			{-conf}        {if {![info exists val]} {incr i; set val [lindex $argv $i]}; set SETTINGS(cfg_file) $val}
			{-location}    {set SETTINGS(location)   1}
			{-overwrites}  {set SETTINGS(overwrites) 1}
			{-quiet}       {set SETTINGS(quiet)      1}
			{-d}           {if {![info exists val]} {incr i; set val [lindex $argv $i]}; set SETTINGS(directory)  $val}
			{-compare}     {if {![info exists val]} {incr i; set val [lindex $argv $i]}; set SETTINGS(compare) $val}
			{-log}         {set SETTINGS(get_log)    1}
			{-view}        {set SETTINGS(viewlog)    1}
			{-tail}        {set SETTINGS(taillog)    1}
			-h -
			--help         {
				printUsage
			}
			--version      {
				set version {$Name: R_Support_Utils_WH_3_0 $}
				if {$version == {$Name: R_Support_Utils_WH_3_0 $}} {
					set version {$Id: analyse_config,v 1.4.4.8 2010-10-26 11:22:48 imiell Exp $}
				}
				puts "OpenBet utility analyse_config, version: $version"
				exit
			}
			default        {set SETTINGS(cfg_file) $param}
		}
	}
} else {
	set SETTINGS(cfg_file)  [lindex $argv 0]
}


# Check the files 
if {$SETTINGS(directory) == "unset"} {
	cd [file dirname $SETTINGS(cfg_file)]
} elseif {$SETTINGS(directory) != "-d"} {
	if [catch {cd $SETTINGS(directory)} msg] {
		puts "Can't find directory : $msg"
		exit
	}
}

# Check Usage
if {![info exists SETTINGS(cfg_file)] || ![file exists $SETTINGS(cfg_file)]} {
	log "Please suppy a valid config file name."
	log ""
	printUsage
	exit 0
}

if {$SETTINGS(directory) == "unset"} {
	regsub {.*/([^/]*)$} $SETTINGS(cfg_file) {\1} SETTINGS(cfg_file)
}

parseFile $SETTINGS(cfg_file) CONFIG


# Build up a second array
if {$SETTINGS(compare) != 0} {
	parseFile $SETTINGS(compare) CONFIG2
	array_compare CONFIG CONFIG2
	return
}






if {$SETTINGS(taillog)} {
	if {[info exists CONFIG(LOG_DIR,value)] && [info exists CONFIG(LOG_FILE,value)] } {
		set current_log "$CONFIG(LOG_DIR,value)/[exec date +$CONFIG(LOG_FILE,value)]"
		if {[file exists $current_log]} {
			puts $current_log
			set tail_file [open "| tail -f $current_log" ]
			fconfigure $tail_file -blocking 0 -buffering line

			while {1} {
				set ::__read ""
				set id [after 2000 {set ::__read "TIMED_OUT"}]
				fileevent $tail_file r {set ::__read "OK"}
				vwait ::__read
				after cancel $id
				fileevent $tail_file r {}
				if {$::__read == "TIMED_OUT"} {
					if {$current_log != "$CONFIG(LOG_DIR,value)/[exec date +$CONFIG(LOG_FILE,value)]"} {
						close $tail_file
						# Wait for next log file to be created
						while {![file exists $current_log]} {
							after 500
						}
						set current_log "$CONFIG(LOG_DIR,value)/[exec date +$CONFIG(LOG_FILE,value)]"
						puts "WARNING : LOG ROTATION moving to $current_log"
						set tail_file [open "| tail -f $current_log" ]
						fconfigure $tail_file -blocking 0 -buffering line
					}
					continue
				}
				puts [gets $tail_file]
			}
			close $tail_file
		} else {
			puts "Log file not found"
		}
	} else {
		puts "Log file not configured"
	}
	return
}


if {$SETTINGS(viewlog)} {
	if {[info exists CONFIG(LOG_DIR,value)] && [info exists CONFIG(LOG_FILE,value)] } {
		set current_log "$CONFIG(LOG_DIR,value)/[exec date +$CONFIG(LOG_FILE,value)]"
		if {[file exists $current_log]} {
			exec "less $current_log"
		} else {
			puts "Log file: $current_log does not exist"
		}
	} else {
		puts "Log file not configured"
	}
	return
}


if {$SETTINGS(get_log)} {
	if {[info exists CONFIG(LOG_DIR,value)] && [info exists CONFIG(LOG_FILE,value)]} {
		puts "$CONFIG(LOG_DIR,value)/[exec date +$CONFIG(LOG_FILE,value)]"
	} else {
		puts "Log file not found"
	}
	return
}

if {!$SETTINGS(quiet) && !$SETTINGS(get_log)} {
	outputConfigs
}

